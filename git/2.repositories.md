### How does Git store information?
In order to make common operations fast and minimize storage space, Git uses a multi-level structure to store data. In simplified form, this has three key parts:

1. Every unique version of every file. (Git calls these blobs because they can contain data of any kind.)
2. tree that tracks the names and locations of a set of files.
3. A commit that records the author, log message, and other properties of a particular commit.

![alt text](https://github.com/oderdene/datacamp/blob/master/git/img/commit-tree-blob.png)

As the diagram shows, each blob is stored only once, and blobs are (frequently) shared between trees. While it may seem redundant to have both trees and commits, a later part of this lesson will show why the two have to be distinct.


### What is a hash?
Every commit to a repository has a unique identifier called a hash (since it is generated by running the changes through a pseudo-random number generator called a hash function). This hash is normally written as a 40-character hexadecimal string like `7c35a3ce607a14953f070f0f83b5d74c2296ef93`, but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.

Hashes are what enable Git to share data efficiently between repositories. If two files are the same, their hashes are guaranteed to be the same. Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.

### How can I view a specific commit?
To view the details of a specific commit, you use the command `git show` with the first few characters of the commit's hash. For example, the command `git show 043070` produces this:

The first part is the same as the log entry shown by `git log`. The second part shows the changes; as with `git diff`, lines that the change removed are prefixed with `-`, while lines that it added are prefixed with `+`.

### What is Git's equivalent of a relative path?
A hash is like an absolute path: it identifies a specific commit. Another way to identify a commit is to use the equivalent of a relative path. The special label `HEAD`, which we saw in the previous chapter, always refers to the most recent commit. The label `HEAD~1` then refers to the commit before it, while `HEAD~2` refers to the commit before that, and so on.

Note that the symbol between `HEAD` and the number is a tilde `~`, not a minus sign `-`, and that there cannot be spaces before or after the tilde.
